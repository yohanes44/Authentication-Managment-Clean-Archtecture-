"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.params = exports.skip = exports.only = exports.pending = exports.retries = exports.timeout = exports.slow = exports.test = exports.suite = exports.context = void 0;
const core = require("@testdeck/core");
function applyTimings(fn, settings) {
    if (settings) {
        if (fn.length === 1) {
            return core.wrap(function (done) {
                if (settings.retries !== undefined) {
                    this.retries(settings.retries);
                }
                if (settings.slow !== undefined) {
                    this.slow(settings.slow);
                }
                if (settings.timeout !== undefined) {
                    this.timeout(settings.timeout);
                }
                return fn.call(this, done);
            }, fn);
        }
        else {
            return core.wrap(function () {
                if (settings.retries !== undefined) {
                    this.retries(settings.retries);
                }
                if (settings.slow !== undefined) {
                    this.slow(settings.slow);
                }
                if (settings.timeout !== undefined) {
                    this.timeout(settings.timeout);
                }
                return fn.call(this);
            }, fn);
        }
    }
    else {
        return fn;
    }
}
const mochaRunner = {
    suite(name, callback, settings) {
        switch (settings && settings.execution) {
            case "only":
                describe.only(name, applyTimings(callback, settings));
                break;
            case "skip":
                describe.skip(name, applyTimings(callback, settings));
                break;
            case "pending":
                // `describe(name);` will not generate pending suite, intentionally skip.
                describe.skip(name, applyTimings(callback, settings));
                break;
            default:
                describe(name, applyTimings(callback, settings));
        }
    },
    test(name, callback, settings) {
        switch (settings && settings.execution) {
            case "only":
                it.only(name, applyTimings(callback, settings));
                break;
            case "skip":
                it.skip(name, applyTimings(callback, settings));
                break;
            case "pending":
                it(name);
                break;
            default:
                it(name, applyTimings(callback, settings));
        }
    },
    beforeAll(name, callback, settings) {
        before(applyTimings(callback, settings));
    },
    beforeEach(name, callback, settings) {
        beforeEach(applyTimings(callback, settings));
    },
    afterEach(name, callback, settings) {
        afterEach(applyTimings(callback, settings));
    },
    afterAll(name, callback, settings) {
        after(applyTimings(callback, settings));
    }
};
class MochaClassTestUI extends core.ClassTestUI {
    // TODO: skipOnError, @context
    constructor(runner = mochaRunner) {
        super(runner);
    }
}
const mochaDecorators = new MochaClassTestUI();
exports.context = mochaDecorators.context, exports.suite = mochaDecorators.suite, exports.test = mochaDecorators.test, exports.slow = mochaDecorators.slow, exports.timeout = mochaDecorators.timeout, exports.retries = mochaDecorators.retries, exports.pending = mochaDecorators.pending, exports.only = mochaDecorators.only, exports.skip = mochaDecorators.skip, exports.params = mochaDecorators.params;
//# sourceMappingURL=index.js.map